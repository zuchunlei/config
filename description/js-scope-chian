今天在论坛上看到了这么一个问题，觉得挺有意思的，就试着自己答答。我是js新手，对js了解的不深，只是按照自己的理解就聊聊。

var array = [];

for(var i=0;i<5;i++){

    array.push(function(){console.log(i);});

}

array[0]();//输出的为什么是5,而不是0.其实array[0-4]输出的都是5。

要回答这个问题，先从函数执行对变量的查找说起。函数执行时对变量的查找是在执行上下文（context）中的作用域链（scope chain）中进行的。

函数对象在创建时，函数对象的内部属性[[scope]]引用着函数的作用域链。也就是说函数对象在创建时，其作用域链就存在了，不管有没有执行。

函数在执行时，js解释器会为函数创建一个执行上下文，作为函数执行的环境。这里的执行上下文和java方法执行时的栈帧作用类似。

执行上下文会为函数创建this与arguments对象。并且加载函数对象的作用域链到执行上下文中，用来进行对变量的查找。

函数对象的作用域链是在函数对象创建的时候创建的（这好像和静态词法分析有点关系，不太懂！），是一个栈结构，栈内的元素是函数的变量对象（Variable Object），栈顶是当前函数对象的变量对象，栈底是全局对象（window/global）的变量对象。如果该函数对象存在外围函数，则作用域链中也会存放外围函数对象的变量对象。

为了说明白作用域链的构成，我们写以下的代码。

var a = 1;

!function f1(){

   var b = 'tang';

   var i = 0;

   return function f2(){

      var c = 'bj'; 

      i++;
      console.log(a+b+c);

  };

}();

我们来分析一下函数对象f2的作用域链的栈结构是怎样的。我们用[]表示变量对象，[a]表示变量对象中存在变量a，用{f - []}表示函数f的变量对象。

f2（[[scope]]属性引用）的作用域链结构类似与  {f2-[c]}--->{f1-[b,i]}--->{window-[a]}。这也就是说为什么在函数f2中可见到变量b，i，a了。因为他们都在自己（函数对象f2）的作用域链中。

回到最初的那道题上来，我们可以做一些简单的修改，让我更好解析一些。

var array = [];

for(var i=0;i<5;i++){

    array.push(function f(){console.log(i);});//这里的f为函数的名字，当然有5个函数对象，他们的名字都是f喽。

}

我们先分析一下函数f在创建时，对象内的作用域链的情况，f的外围是全局环境。

f的作用域链结构 {f-[]}---->{window:[array,i]}.五个函数对象f的作用域链结构都是这样的。

我们可以看到为什么array[0]()或者array[4]()执行后得到的值是5,因为函数f中变量i在window的变量对象上，i的值就是5.

那如何改正才能达到我们想要的效果呢？

var array = [];

for(var i=0;i<5;i++){

    array.push(function a(){

         var data = i;

         return function b(){

               console.log(data);

        };

    }());

}

我们分析一下当前array数组中函数对象的作用域链的情况吧。把变量对象中的值也加上，看起来会更好一些。

array[0] : {b-[]}---->{a-[data=0]}----->{window-[array,i=5]}

array[1] : {b-[]}---->{a-[data=1]}----->{window-[array,i=5]}

array[2] : {b-[]}---->{a-[data=2]}----->{window-[array,i=5]}

array[3] : {b-[]}---->{a-[data=3]}----->{window-[array,i=5]}

array[4] : {b-[]}---->{a-[data=4]}----->{window-[array,i=5]}

这就是我分析的全部过程，没有引用闭包什么的，但是我觉得函数a的变量对象（{a-[data=2]}）就是以闭包方式存在的。

-------------------------------------------------------------------------------------------------------------------------------------------------------------------

函数对象的作用域链是在函数对象创建的时候创建的。函数在执行时对变量的查找是在函数对象的作用域链上进行的！



代码部分格式化工作交给tangroot啦！